---
title: 'Manipulando listas e mapas no Flutter'
publishedAt: '2023-11-06'
summary: 'Manipulando listas e mapas no Flutter'
---

<aside>
üö® *Voc√™ pode copiar esses exemplos e utiliz√°-los no [Dartpad](https://dartpad.dev/) para testar e observar o funcionamento de cada um dos m√©todos.*

</aside>

## Listas em Flutter

As listas s√£o estruturas de dados que permitem armazenar valores em uma sequ√™ncia ordenada. Em outras palavras, voc√™ pode pensar nelas como uma cole√ß√£o de itens numerados. Em muitas outras linguagens de programa√ß√£o, as listas s√£o chamadas de "arrays".

```dart
void main() {
// Criando uma lista de n√∫meros
  List<int> numbers = [1, 2, 3, 4, 5];
  print(numbers);

// Adicionando um elemento √† lista
  numbers.add(6);
  print(numbers);

// Adicionando v√°rios elementos √† lista
  List<int> newNumbers = [7, 8, 9, 10];
  numbers.addAll(newNumbers);
  print(numbers);

  // Removendo um elemento da lista
  numbers.remove(2);
  print(numbers);
  
  // Removendo um item da lista pela sua posi√ß√£o
  numbers.removeAt(0);
  print(numbers);
  
  // Obtendo o comprimento da lista
  print(numbers.length);
}
```

### Filtrando uma Lista com `.where`

- Percorre a lista e retorna os elementos que satisfazem uma determinada condi√ß√£o.
- N√£o modifica a lista existente, ele retorna uma nova lista contendo os elementos que satisfazem a condi√ß√£o especificada. Portanto, a lista original permanece inalterada.

```dart
void main() {
  // Criando uma lista de n√∫meros
  List<int> numbers = [1, 2, 3, 4, 5];
  print(numbers);

  // Filtrando uma lista de acordo com uma condi√ß√£o
  var numbersFiltered = numbers.where((x) => x < 3);
  print(numbersFiltered);

  // O que a .where retorna?
  print(numbersFiltered.runtimeType);

  // Convertendo um Iterable para lista
  numbersFiltered = numbers.where((x) => x < 3).toList();
  print(numbersFiltered);

  // O que a .where retorna agora? Uma lista!
  print(numbersFiltered.runtimeType);
}
```

Quando trabalhamos usando o `.where` precisamos nos atendar pois o seu retorno √© do tipo **`Iterable<type>`,** ou seja, n√£o conseguimos usar v√°rios m√©todos espec√≠ficos das listas aqui. Para resolver isso, usamos o `.toList()` para converter esse `Iterable` em uma lista.

**`List`** √© um tipo de cole√ß√£o ordenada que estende **`Iterable`**, oferecendo opera√ß√µes espec√≠ficas para lidar com elementos em uma ordem espec√≠fica. **`Iterable`**, por outro lado, √© uma interface mais gen√©rica para lidar com sequ√™ncias de elementos, mas n√£o tem a mesma garantia de ordem que uma lista.

### Ordenando uma Lista com `.sort`

- O m√©todo `.sort` √© usado para ordenar os elementos de uma lista com base em um crit√©rio espec√≠fico.
- Voc√™ pode fornecer uma fun√ß√£o de compara√ß√£o personalizada para o **`.sort()`** para ordenar os elementos de acordo com crit√©rios espec√≠ficos. Isso permite uma flexibilidade maior na ordena√ß√£o.
- O **`.sort()`** modifica a lista original e n√£o retorna uma nova lista ordenada. Portanto, tenha cuidado ao usar este m√©todo se precisar manter a lista original inalterada.

```dart
void main() {
  // Criando uma lista de n√∫meros
  List<int> numbers = [5, 2, 8, 1, 9, 3, 7, 6, 4];

  print(numbers);

  // Ordenando a lista em ordem crescente
  numbers.sort();
  print(numbers);

  // Usando o m√©todo "compareTo"
  // Ordenando a lista em ordem decrescente
  numbers.sort((a, b) => b.compareTo(a));
  print(numbers);

  // Usando um m√©todo personalizado para ordenar
  // Ordenando a lista pelos n√∫meros pares primeiro, e depois pelos √≠mpares
  numbers.sort((a, b) {
    bool parA = a % 2 == 0;
    bool parB = b % 2 == 0;

    if (parA && !parB) {
      return -1; // a vem antes de b (n√∫meros pares primeiro)
    } else if (!parA && parB) {
      return 1; // b vem antes de a (n√∫meros pares primeiro)
    } else {
      return a - b; // se ambos s√£o pares ou √≠mpares, ordene numericamente
    }
  });
  print(numbers);
}
```

## Conjuntos em Flutter

Os conjuntos (sets) s√£o semelhantes √†s listas, com a diferen√ßa de que constituem uma cole√ß√£o de elementos √∫nicos e n√£o ordenados.

```dart
void main() {
	// Criando um conjunto de n√∫meros
  Set<int> numbers = {1, 3, 5, 7, 3, 5, 9, 2, 1};
	// Neste exemplo, estamos criando um conjunto que cont√©m os n√∫meros inteiros 1, 3, 5, 7, 3 (repetido), 5 (repetido), 9, 2 e 1 (repetido).
	// Como um conjunto s√≥ aceita elementos √∫nicos, as duplicatas ser√£o automaticamente removidas.
  print(numbers);
}
```

A escolha entre usar um **`Set`** ou uma **`List`** no Flutter (ou em qualquer linguagem de programa√ß√£o) depende do que voc√™ est√° tentando realizar com os dados e das caracter√≠sticas espec√≠ficas do seu aplicativo.

**Use um `Set` quando**:

1. Voc√™ precisa garantir a unicidade dos elementos.
2. **V**oc√™ n√£o se importa com a ordem dos elementos.

**Use uma `List` quando**:

1. Voc√™ precisa manter a ordem dos elementos.
2. Voc√™ precisa acessar elementos por √≠ndice.
3. Voc√™ precisa adicionar ou remover elementos de forma din√¢mica.

## M√©todo ‚Äú.any()‚Äù

O m√©todo **`any`** no Flutter (e na linguagem Dart, na qual o Flutter √© baseado) √© uma fun√ß√£o associada a cole√ß√µes (como listas, conjuntos, e outros tipos que implementam o conceito de iter√°veis). Sua fun√ß√£o √© verificar se pelo menos um elemento na cole√ß√£o satisfaz uma determinada condi√ß√£o, resultando em um retorno de **`true`** caso a condi√ß√£o seja verdadeira para ao menos um elemento, e **`false`** se nenhum elemento cumprir a condi√ß√£o.

```dart
void main() {
  // Criando uma lista de n√∫meros
  List<int> numbers = [1, 3, 5, 7, 9];
  // Usando o m√©todo "any" e atribuindo o resultado a uma vari√°vel
  bool hasEvenNumber = numbers.any((number) => number % 2 == 0);
  
  if (hasEvenNumber) {
    print("A lista tem n√∫meros pares.");
  } else {
    print("A lista n√£o tem n√∫meros pares.");
  }
}
```

### Diferen√ßa entre o m√©todo ‚Äúany‚Äù e o m√©todo ‚Äúwhere‚Äù

- **`any`**: retorna **`true`** se pelo menos um elemento atender √† condi√ß√£o.
- **`where`**: retorna uma nova cole√ß√£o contendo todos os elementos que atendem √† condi√ß√£o.

## Mapas em Flutter

Os mapas funcionam como dicion√°rios, associando chaves a valores. Eles oferecem uma grande flexibilidade em termos de organiza√ß√£o de dados.

**Exemplo de Mapa:**

```dart
void main() {
  // Criando um mapa de frutas e suas cores
  Map<String, dynamic> person = {
    'Name': 'Leticia',
    'Age': 22,
  };

  // Adicionando um novo par chave-valor
  person['Gender'] = 'Female';

  print(person);
}

```

## Convertendo um mapa em uma lista de objetos

Nesse exemplo, a classe **`Clothing`** √© respons√°vel por representar informa√ß√µes sobre pe√ßas de roupa. Vamos explorar dois m√©todos essenciais desta classe: **`fromMap`** e **`fromMaps`**.

Esses m√©todos s√£o essenciais quando se trabalha com dados provenientes de fontes externas, como APIs ou bases de dados, e facilitam a convers√£o de mapas em objetos de forma eficaz e organizada.

```dart
// Classe Clothing
class Clothing {
  // ... (atributos e construtores)

  // Converte um mapa em um objeto Clothing
  Clothing.fromMap(Map<String, dynamic> map)
      : id = map['id'],
        title = map['title'],
        bannerPath = map['banner']['url'],
        price = double.parse(map['price'] ?? '0');

  // Converte uma lista de mapas em uma lista de objetos Clothing
  static List<Clothing> fromMaps(List<dynamic> maps) {
    return maps.map((map) {
      return Clothing.fromMap(map);
    }).toList();
  }
}
```

### M√©todo **`fromMap`**

O m√©todo **`fromMap`** transforma um mapa em um objeto **`Clothing`**, permitindo a f√°cil convers√£o de dados provenientes de fontes externas em inst√¢ncias utiliz√°veis.

Este m√©todo utiliza as chaves do mapa para inicializar os atributos **`id`**, **`title`**, **`bannerPath`** e **`price`** da inst√¢ncia de **`Clothing`**.

### M√©todo **`fromMaps`**

O m√©todo **`fromMaps`** √© est√°tico, o que significa que pertence √† classe **`Clothing`** e n√£o a uma inst√¢ncia espec√≠fica. Ele √© utilizado para converter uma lista de mapas em uma lista de objetos **`Clothing`**.

Ele percorre a lista de mapas e, para cada mapa, utiliza o m√©todo **`fromMap`** para criar um objeto **`Clothing`**, resultando em uma lista de pe√ßas de roupa prontas para serem utilizadas.